<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>a polyglot&#39;s hacks </title>
    <link>https://lbarasti.github.io/post/</link>
    <language>en-us</language>
    <author>Lorenzo Barasti</author>
    <rights>(C) 2017</rights>
    <updated>2017-04-12 10:12:33 &#43;0100 BST</updated>

    
      
        <item>
          <title>Going faster with Crystal</title>
          <link>https://lbarasti.github.io/post/fun_with_crystal/</link>
          <pubDate>Wed, 12 Apr 2017 10:12:33 BST</pubDate>
          <author>Lorenzo Barasti</author>
          <guid>https://lbarasti.github.io/post/fun_with_crystal/</guid>
          <description>

&lt;p&gt;Recently, I have been having some fun with some algorithmic challenges from one of the Algorithms courses on Coursera. The language I like to use for this kind of things is ruby.&lt;/p&gt;

&lt;p&gt;When designing an algorithm it&amp;rsquo;s important for me to understand why brute force doesn&amp;rsquo;t work. I like to &lt;em&gt;count&lt;/em&gt; the reasons why that approach is not feasible. One way of doing that is to write a naive implementation and make considerations about its run time.&lt;/p&gt;

&lt;p&gt;Consider the following problem.&lt;/p&gt;

&lt;p&gt;We are given a set of 2D points with integer coordinates. So one such point could be the tuple &lt;code&gt;[3,8]&lt;/code&gt;.
We define the distance between two points &lt;code&gt;u,v&lt;/code&gt; as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dist(u,v) = |x_u - x_v| + |y_u - y_v|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;|x|&lt;/code&gt; is the absolute value of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, for instance, &lt;code&gt;dist([1,3], [4,2]) = 4&lt;/code&gt;. Our task is to group the given points so that the minimum distance between any two groups - let&amp;rsquo;s call them &lt;em&gt;clusters&lt;/em&gt; - is at least 3.&lt;/p&gt;

&lt;p&gt;The pseudo-code for my brute-force implementation of this problem might look like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in 1..n
  for j in i+1..n
    if dist(i,j) &amp;lt; 3
      merge_clusters(i, j)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, it&amp;rsquo;s not clear how exactly we are going to keep track of which cluster a point is in at any given time, but even assuming we can do that efficiently with respect to the size of the problem - i.e. the number of points - we have a more urgent issue to deal with.&lt;/p&gt;

&lt;p&gt;Try running the following ruby code for different values of &lt;code&gt;size&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;size = 10 ** 5
a = (1..size).map{ [rand(1000), rand(1000)] }

def dist(u,v)
  (u[0] - v[0]).abs + (u[1] - v[1]).abs
end

a.each_with_index {|u,i|
  print &amp;quot;\r#{i}&amp;quot; if i % 100 == 0
  a[i + 1..-1].each_with_index {|v,j|
    dist(u,v) &amp;lt; 3
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On my machine the run time factor between &lt;code&gt;size = 10^4&lt;/code&gt; and &lt;code&gt;size = 10^5&lt;/code&gt; is about &lt;b&gt;100&lt;/b&gt;. In particular, going through the nested for-loop with 100_000 elements takes over 20 minutes. And we are not even computing the clusters yet!&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;m thinking, maybe there&amp;rsquo;s a better way of dealing with this, maybe we don&amp;rsquo;t need to go through the array twice. On the other hand, maybe an interpreted language like ruby is just not the right tool for the job.&lt;/p&gt;

&lt;p&gt;A friend recently told me about the Crystal language. He was so excited about it that I thought &amp;ldquo;Maybe this is the right time to give it a go&amp;rdquo;. To make things even easier, Crystal syntax is so similar to ruby, that you might be lucky enough and not even have to change a thing in your code to try it!&lt;/p&gt;

&lt;p&gt;so after installing Crystal, I tried
&lt;code&gt;crystal loop.rb&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The runtime for size = 100_000 is still over 12 minutes.&lt;/p&gt;

&lt;p&gt;Is that it? Not really, the &amp;ldquo;getting started&amp;rdquo; guide to Crystal recommends you compile your source code once you&amp;rsquo;re happy with it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;crystal build loop.rb --release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this spits out a blazing fast &lt;code&gt;loop&lt;/code&gt; executable that runs in just 70 seconds. We just cut the run time by a factor of &lt;b&gt;10&lt;/b&gt; and all we had to do was to compile and run our code with Crystal! To summarize&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language &lt;br/&gt;&lt;/th&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;~23 minutes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Node&lt;/td&gt;
&lt;td&gt;3.5 minutes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Crystal&lt;/td&gt;
&lt;td&gt;1.2 minutes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br/&gt;
So next time you&amp;rsquo;re facing a computational challenge, why don&amp;rsquo;t you give Crystal a try!&lt;/p&gt;

&lt;h2 id=&#34;source-code&#34;&gt;Source code&lt;/h2&gt;

&lt;p&gt;You can find the source code used to generate the bechmark data above &lt;a href=&#34;https://lbarasti.github.io/src/fun_with_crystal/&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
